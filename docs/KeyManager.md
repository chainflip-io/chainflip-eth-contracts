# `KeyManager`

  Holds the aggregate and governance keys, functions to update them,
          and isUpdatedValidSig so other contracts can verify signatures and updates _lastValidateTime

## `validTime()`

   Check that enough time has passed for setAggKeyWithGovKey. Needs
        to be done as a modifier so that it can happen before updatedValidSig

## `isGovernor()`

## `updatedValidSig(struct IShared.SigData sigData, bytes32 contractMsgHash)`

   Call isUpdatedValidSig

## `constructor(struct IShared.Key _aggKey, address _govKey)` (public)

No description

## `setCanValidateSig(address[] addrs)` (external)

 Sets the specific addresses that can call isValidSig. This
         function can only ever be called once! Yes, it's possible to
         frontrun this, but honestly, it's fine in practice - it just
         needs to be set up successfully once, which is trivial

- `addrs`:   The addresses to whitelist

## `isUpdatedValidSig(struct IShared.SigData sigData, bytes32 contractMsgHash) → bool` (public)

 Checks the validity of a signature and msgHash, then updates _lastValidateTime

- `sigData`:   The keccak256 hash over the msg (uint) (here that's normally
                 a hash over the calldata to the function with an empty sigData)
                 from the current aggregate key (uint)

- `contractMsgHash`:   The hash of the thing being signed but generated by the contract
                 to check it against the hash in sigData (bytes32) (here that's normally
                 a hash over the calldata to the function with an empty sigData)

Returns

- Bool used by caller to be absolutely sure that the function hasn't reverted

## `setAggKeyWithAggKey(struct IShared.SigData sigData, struct IShared.Key newKey)` (external)

 Set a new aggregate key. Requires a signature from the current aggregate key

- `sigData`:   The keccak256 hash over the msg (uint) (which is the calldata
                 for this function with empty msgHash and sig) and sig over that hash
                 from the current aggregate key (uint)

- `newKey`:    The new aggregate key to be set. The x component of the pubkey (uint),
                 the parity of the y component (uint8)

## `setAggKeyWithGovKey(struct IShared.Key newKey)` (external)

 Set a new aggregate key. Requires a signature from the current governance key

- `newKey`:    The new aggregate key to be set. The x component of the pubkey (uint),
                 the parity of the y component (uint8)

## `setGovKeyWithGovKey(address newKey)` (external)

 Set a new governance key. Requires a signature from the current governance key

- `newKey`:    The new governance key to be set. The x component of the pubkey (uint),
                 the parity of the y component (uint8)

## `getAggregateKey() → struct IShared.Key` (external)

 Get the current aggregate key

Returns

- The Key struct for the aggregate key

## `getGovernanceKey() → address` (external)

 Get the current governance key

Returns

- The Key struct for the governance key

## `getLastValidateTime() → uint256` (external)

 Get the last time that a function was called which
         required a signature from _aggregateKeyData or_governanceKeyData

Returns

- The last time isUpdatedValidSig was called, in unix time (uint)

## `isNonceUsedByAggKey(uint256 nonce) → bool` (external)

 Get whether or not the specific keyID has used this nonce before
         since it cannot be used again

Returns

- Whether the nonce has already been used (bool)

## `canValidateSig(address addr) → bool` (external)

 Get whether addr is whitelisted for validating a sig

- `addr`:  The address to check

Returns

- Whether or not addr is whitelisted or not

## `canValidateSigSet() → bool` (external)

 Get whether or not _canValidateSig has already been set, which
         prevents it from being set again

Returns

- The value of _canValidateSigSet

## `receive()` (external)

 @notice Allows this contract to receive ETH used to refund callers
